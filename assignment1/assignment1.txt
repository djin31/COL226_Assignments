type 'a tree = Nil|Node of 'a|S of 'a tree* 'a tree;;

exception AtFirst;;

exception AtLast;;

let succ s = match s with
		(Nil,S(Node a,_))->a|(S(_,_),S(Node a,_))->a|_-> raise Empty;;

let length s = match s with 
		Nil->0|Node a->1|S (s1,s2)->(length s1)+ (length s2);;


type 'a mystring  = 'a tree * hd of 'a * tl of 'a;;

let x = (S (S(Nil,Node 2),S(Node 3,Node 4)),S(Node 5,Node 6));;

----------------------------------------------------------------------------------

type 'a mystring  = {mutable seen: 'a list;mutable unseen: 'a list;mutable head: 'a;mutable tail: 'a};;

exception AtFirst;;

exception AtLast;;

let rec listlength l = match l with
		[] -> 0 | x::xs -> 1 + (listlength xs);;

let lgh s = match s with
		{seen=l1;unseen=l2} -> (listlength l1) + (listlength l2);;

let nonempty s = match s with
			{unseen=[]} -> false
			|_ -> true;;


let rec listreverse l = match l with
		[]->[]|[a]->[a]|x::xs -> (listreverse xs)@[x];;


let concat s1 s2 = match s1 with
				{unseen=[]} -> s1.unseen <- s1.unseen @ (listreverse s2.seen) @ s2.unseen; s1.tail <- s2.tail; s1.head <- s2.head
				|{unseen = x::xs} -> s1.unseen <- s1.unseen @ (listreverse s2.seen) @ s2.unseen; s1.tail <- s2.tail;;

concat {seen=[];unseen=[];head=None;tail=None} {seen=[];unseen=[];head=None;tail=None};;

let listtail l = match l with
		[]->[]|[a]->[a]|x::xs -> xs;;

let listhead l = match l with
		[]->raise AtLast|[a]->a|x::xs->x;;

-------------------------------------------------
let rec reverse s = match s with
				{seen=l1;unseen=l2;head=h;tail=t} -> {seen = listreverse l2;unseen = listreverse l1;head = t; 	tail = h};; //if new obj was to be returned
--------------------------------------------------
let rec reverse s = 
	let l1 = (listreverse s.seen) in
	let l2 = (listreverse(listtail s.unseen)) in
	let h = s.head in
	let t = s.tail in
	let pointer = (listhead s.unseen) in
	s.seen<-l2;s.unseen<-pointer::l1;s.head<-t;s.tail<-h;; //if original had to be changed

let s={seen = [1;2];unseen = [3;4];head = 2;tail=4};;
reverse s;;	

let first s = s.head;;

let last s = s.tail;;

let forward s = match s with
			{seen=l1;unseen=x::y::xs} -> s.seen <- x::l1; s.unseen <- y::xs
			|_ -> raise AtLast;;

let back s = match s with
			{seen = x::xs;unseen = l2} -> s.seen <-xs ; s.unseen <- x::l2
			|_ -> raise AtFirst;;

let replace s w = match s with
			{unseen=[]} -> raise AtLast
			|{seen=[];unseen=[x]} -> s.unseen <- [w]; s.head<- w; s.tail <-w
			|{seen=h1::t1;unseen=[x]} -> s.unseen <- [w];s.tail <-w
			|{seen= []; unseen = x::y::xs} -> s.unseen <- w::y::xs; s.head <- w
			|{seen = h1::t1; unseen = x::y::xs} -> s.unseen <- w::y::xs;;

let create val = 
	let n = String.length val in
	let s = {seen=[];unseen=[];head=[];tail=[]}
	for i = 0 to n-1 do
		l = l@[String.get val i]
	done;
	l;;

------------------------------------------------------------
type mystring  = {mutable seen: char list;mutable unseen: char list;mutable head: char ;mutable tail: char};;

exception AtFirst;;

exception AtLast;;

exception TooShort;;

let rec listlength l = match l with
		[] -> 0 | x::xs -> 1 + (listlength xs);;

let lgh s = match s with
		{seen=l1;unseen=l2} -> (List.length l1) + (List.length l2);;

let nonempty s = match s with
		{unseen=[]} -> false
		|_ -> true;;

let rec listreverse l = match l with
		[]->[]|[a]->[a]|x::xs -> (listreverse xs)@[x];;

let concat s1 s2 = match s1,s2 with
		({unseen=[]},{unseen=[]}) -> s1
		|({unseen = x::xs},{unseen = []}) -> s1
		|({unseen = []},{unseen = x::xs}) -> s2
		|({unseen = x::xs},{unseen = y::ys}) -> {seen = s1.seen;unseen = s1.unseen @ (listreverse s2.seen) @ s2.unseen; head = s1.head;tail = s2.tail};;

let listtail l = match l with
		[]->[]|[a]->[a]|x::xs -> xs;;

let listhead l = match l with
		[]->raise AtLast|[a]->a|x::xs->x;;

let reverse s = match s with
		{unseen=[]}->s
		|{unseen=x::xs}-> {seen= listreverse xs; unseen = x:: (listreverse s.seen); head=s.tail; tail= s.head};;

let first s = s.head;;

let last s = s.tail;;

let forward s = match s with 
		{unseen=[a]}-> raise AtLast
		|{unseen = []} -> raise AtLast
		|{seen = l1; unseen = x::y::xs} -> {seen=x::l1; unseen = y::xs; head = s.head; tail = s.tail};;

let back s = match s with
		{seen =[]} -> raise AtFirst
		|{seen = x::xs} -> {seen = xs; unseen = x::s.unseen ; head = s.head; tail = s.tail};;

let rec chararray i s l =
	if i < 0 then l else chararray (i - 1) s (s.[i] :: l);;

let rec listend l = match l with 
		[]->raise TooShort|[a]-> a|x::xs -> listend xs;;


let create s = 
	let l = chararray (String.length s - 1) s [] in
	match l with
		[]-> {seen=[];unseen=[];head='a';tail='a'}
		|x::xs -> {seen=[];unseen=x::xs;head = x; tail = listend (x::xs) };;

let replace s w = match s with
			{unseen=[]} -> raise AtLast
			|{seen=[];unseen=[x]} -> {seen=[];unseen = [w]; head = w; tail = w}
			|{seen=h1::t1;unseen=[x]} -> {seen = h1::t1; unseen = [w]; head= s.head; tail = w}
			|{seen= []; unseen = x::y::xs} -> {seen = []; unseen = w::y::xs; head = w; tail = s.tail} 
			|{seen = h1::t1; unseen = x::y::xs} -> {seen = s.seen; unseen = w::y::xs; head = s.head ; tail = s.tail};;

let moveto n s = 
	if n >= (String.length s) then raise TooShort
	else
		let es = ref (create s) in
		for i = 0 to n-1 do
			es := forward !es
		done;
		!es;;
